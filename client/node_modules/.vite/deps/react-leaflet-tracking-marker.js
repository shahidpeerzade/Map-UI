import {
  init_lib,
  lib_exports
} from "./chunk-DYOTDQ2M.js";
import "./chunk-OZ6A2BMG.js";
import "./chunk-K3XTCCNO.js";
import {
  require_leaflet_src
} from "./chunk-KQ4EBO2O.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-GFT2G5UO.js";

// node_modules/react-leaflet-tracking-marker/BaseMarker.js
var require_BaseMarker = __commonJS({
  "node_modules/react-leaflet-tracking-marker/BaseMarker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BaseMarker = void 0;
    var _leaflet = _interopRequireDefault(require_leaflet_src());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var oldIE = _leaflet["default"].DomUtil.TRANSFORM === "msTransform";
    _leaflet["default"].BaseMarker = _leaflet["default"].Marker.extend({
      options: {
        bearingAngle: 0,
        rotationOrigin: ""
      },
      initialize: function initialize(latlng, options) {
        _leaflet["default"].Marker.prototype.initialize.call(this);
        _leaflet["default"].Util.setOptions(this, options);
        this._latlng = _leaflet["default"].latLng(latlng);
        var iconOptions = this.options.icon && this.options.icon.options;
        var iconAnchor = iconOptions && this.options.icon.options.iconAnchor;
        if (iconAnchor) {
          iconAnchor = iconAnchor[0] + "px " + iconAnchor[1] + "px";
        }
        this.options.rotationOrigin = this.options.rotationOrigin || iconAnchor || "center";
        this.options.bearingAngle = this.options.bearingAngle || 0;
        this.on("drag", function(e) {
          e.target._applyRotation();
        });
        this.on("move", this.slideCancel, this);
        this._slideToUntil = 0;
        this._slideToDuration = 1e3;
        this._slideToLatLng = [0, 0];
        this._slideFromLatLng = [0, 0];
        this._slideKeepAtCenter = false;
        this._slideDraggingWasAllowed = false;
        this._slideFrame = 0;
      },
      slideTo: function slideTo(latlng, options) {
        if (!this._map)
          return;
        this._slideToDuration = options.duration;
        this._slideToUntil = performance.now() + options.duration;
        this._slideFromLatLng = this.getLatLng();
        this._slideToLatLng = latlng;
        this._slideKeepAtCenter = !!options.keepAtCenter;
        this._slideDraggingWasAllowed = this._slideDraggingWasAllowed !== void 0 ? this._slideDraggingWasAllowed : this._map.dragging.enabled();
        if (this._slideKeepAtCenter) {
          this._map.dragging.disable();
          this._map.doubleClickZoom.disable();
          this._map.options.touchZoom = "center";
          this._map.options.scrollWheelZoom = "center";
        }
        this.fire("movestart");
        this._slideTo();
        return this;
      },
      _slideTo: function _slideTo() {
        if (!this._map)
          return;
        var remaining = this._slideToUntil - performance.now();
        if (remaining < 0) {
          this.setLatLng(this._slideToLatLng);
          this.fire("moveend");
          if (this._slideDraggingWasAllowed) {
            this._map.dragging.enable();
            this._map.doubleClickZoom.enable();
            this._map.options.touchZoom = true;
            this._map.options.scrollWheelZoom = true;
          }
          this._slideDraggingWasAllowed = false;
          return this;
        }
        var startPoint = this._map.latLngToContainerPoint(this._slideFromLatLng);
        var endPoint = this._map.latLngToContainerPoint(this._slideToLatLng);
        var percentDone = (this._slideToDuration - remaining) / this._slideToDuration;
        var currPoint = endPoint.multiplyBy(percentDone).add(startPoint.multiplyBy(1 - percentDone));
        var currLatLng = this._map.containerPointToLatLng(currPoint);
        this.setLatLng(currLatLng);
        if (this._slideKeepAtCenter) {
          this._map.panTo(currLatLng, {
            animate: false
          });
        }
        this._slideFrame = _leaflet["default"].Util.requestAnimFrame(this._slideTo, this);
      },
      // 🍂method slideCancel(): this
      // Cancels the sliding animation from `slideTo`, if applicable.
      slideCancel: function slideCancel() {
        _leaflet["default"].Util.cancelAnimFrame(this._slideFrame);
      },
      onRemove: function onRemove(map) {
        _leaflet["default"].Marker.prototype.onRemove.call(this, map);
      },
      _setPos: function _setPos(pos) {
        _leaflet["default"].Marker.prototype._setPos.call(this, pos);
        this._applyRotation();
      },
      _applyRotation: function _applyRotation() {
        if (this.options.bearingAngle) {
          this._icon.style[_leaflet["default"].DomUtil.TRANSFORM + "Origin"] = this.options.rotationOrigin;
          if (oldIE) {
            this._icon.style[_leaflet["default"].DomUtil.TRANSFORM] = "rotate(" + this.options.bearingAngle + "deg)";
          } else {
            this._icon.style[_leaflet["default"].DomUtil.TRANSFORM] += " rotateZ(" + this.options.bearingAngle + "deg)";
          }
        }
      },
      setRotationAngle: function setRotationAngle(angle) {
        this.options.bearingAngle = angle;
        this.update();
        return this;
      },
      setRotationOrigin: function setRotationOrigin(origin) {
        this.options.rotationOrigin = origin;
        this.update();
        return this;
      }
    });
    _leaflet["default"].baseMarker = function(latlng, options) {
      return new _leaflet["default"].BaseMarker(latlng, options);
    };
    var BaseMarker = _leaflet["default"].BaseMarker;
    exports.BaseMarker = BaseMarker;
  }
});

// node_modules/react-leaflet-tracking-marker/LeafletTrackingMarker.js
var require_LeafletTrackingMarker = __commonJS({
  "node_modules/react-leaflet-tracking-marker/LeafletTrackingMarker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LeafletTrackingMarker = void 0;
    var _core = (init_lib(), __toCommonJS(lib_exports));
    var _BaseMarker = require_BaseMarker();
    var _excluded = ["position", "previousPosition", "rotationAngle"];
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var defaultPosition = [0, 0];
    var computeBearing = function computeBearing2() {
      var previousPosition = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultPosition;
      var nexPosition = arguments.length > 1 ? arguments[1] : void 0;
      var bearing = Math.atan2(nexPosition[0] - previousPosition[0], nexPosition[1] - previousPosition[1]);
      bearing = bearing * (180 / Math.PI);
      bearing = (bearing + 360) % 360;
      bearing = 360 - bearing;
      return bearing;
    };
    var createMarker = function createMarker2(_ref, ctx) {
      var position = _ref.position, previousPosition = _ref.previousPosition, rotationAngle = _ref.rotationAngle, options = _objectWithoutProperties(_ref, _excluded);
      var bearingAngle = rotationAngle !== null && rotationAngle !== void 0 ? rotationAngle : computeBearing(previousPosition, position);
      var instance = new _BaseMarker.BaseMarker(position, _objectSpread(_objectSpread({}, options), {}, {
        bearingAngle
      }));
      return {
        instance,
        context: _objectSpread(_objectSpread({}, ctx), {}, {
          overlayContainer: instance
        })
      };
    };
    var updateMarker = function updateMarker2(marker, props, prevProps) {
      var position = props.position, previousPosition = props.previousPosition, duration = props.duration, keepAtCenter = props.keepAtCenter, icon = props.icon, zIndexOffset = props.zIndexOffset, opacity = props.opacity, draggable = props.draggable, rotationOrigin = props.rotationOrigin, rotationAngle = props.rotationAngle;
      if (prevProps.position !== position && typeof duration == "number") {
        marker.slideTo(position, {
          duration,
          keepAtCenter
        });
      }
      if (icon && icon !== prevProps.icon) {
        marker.setIcon(icon);
      }
      if (zIndexOffset && zIndexOffset !== prevProps.zIndexOffset) {
        marker.setZIndexOffset(zIndexOffset);
      }
      if (opacity && opacity !== prevProps.opacity) {
        marker.setOpacity(opacity);
      }
      if (marker.dragging && draggable !== prevProps.draggable) {
        if (draggable === true) {
          marker.dragging.enable();
        } else {
          marker.dragging.disable();
        }
      }
      if (rotationAngle !== null && rotationAngle !== void 0) {
        marker.setRotationAngle(rotationAngle);
      } else if ((previousPosition === null || previousPosition === void 0 ? void 0 : previousPosition[0]) !== position[0] && (previousPosition === null || previousPosition === void 0 ? void 0 : previousPosition[1]) !== position[1]) {
        var bearingAngle = computeBearing(previousPosition, position);
        marker.setRotationAngle(bearingAngle);
      }
      if (rotationOrigin !== prevProps.rotationOrigin) {
        marker.setRotationOrigin(rotationOrigin);
      }
    };
    var LeafletTrackingMarker = (0, _core.createLayerComponent)(createMarker, updateMarker);
    exports.LeafletTrackingMarker = LeafletTrackingMarker;
  }
});

// node_modules/react-leaflet-tracking-marker/index.js
var require_react_leaflet_tracking_marker = __commonJS({
  "node_modules/react-leaflet-tracking-marker/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "LeafletTrackingMarker", {
      enumerable: true,
      get: function get() {
        return _LeafletTrackingMarker.LeafletTrackingMarker;
      }
    });
    var _LeafletTrackingMarker = require_LeafletTrackingMarker();
  }
});
export default require_react_leaflet_tracking_marker();
//# sourceMappingURL=react-leaflet-tracking-marker.js.map
